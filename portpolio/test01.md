# 외부 API 종속성을 넘어: 안정적인 데이터 파이프라인 구축
Hips-Tour의 핵심 데이터는 한국관광공사의 `TourAPI`에 전적으로 의존합니다.
이는 풍부한 데이터를 활용할 수 있다는 장점이 있지만, 동시에 서비스의 안정성과 확장성을 위협하는 치명적인 제약이 존재합니다.
이 글에서는 해당 제약들을 어떻게 해결하고, 안정적인 데이터 파이프라인 역할을 하는 sync모듈을 구축했는지 그 과정을 상세히 공유하고자 합니다.

---

## 문제 정의: 통제 불가능한 외부 요인들
개발 초기, 두 가지 통제 불가능한 외부 요인에 직면했습니다.
+ 호출 수 제한
TourAPI는 `일일 API 호출을 1,000회로 제한`합니다.
서비스에 필요한 초기 데이터는 약 3만건으로 단순 계산 시 초기 데이터 확보에만 30일이 소요됩니다.
사실상 런칭이 불가능한 상황입니다.
+ 높은 응답 지연
사용자 요청 시마다 실시간으로 외부 API를 호출하는 것은 네트워크 상태와 외부 서버의 컨디션에 따라 응답 속도가 불규칙하게 변동되는 문제를 야기합니다.
이는 일관된 사용자 경험 제공을 불가능하게 만드는 요인이었습니다.

```text
이 문제들을 해결하기 위해, 외부 API에 대한 의존성을 끊고,
서비스가 직접 통제할 수 있는 내무 데이터베이스를 구축하는 것을 목표로 설정했습니다.
이 목표를 수행할 독립적인 데이터 파이프라인, sync 모듈의 개발을 시작합니다.
```

---

## 1차 전략: 책임 분리를 통한 접근
모든 데이터를 동기화하는 작업을 하나의 로직으로 처리하는 것은 위험하다고 판단했습니다.
대규모의 초기 데이터 적재와 변경된 데이터의 업데이트는 그 목적과 성격이 다르기 때문입니다.
따라서 `sync`모듈 내에 두 개의 다른 책임을 가진 서비스를 설계했습니다.

+ `LoadService` - 초기 데이터 적재<br>
서비스 운영 전, 수만 건의 전체 데이터를 TourAPI로부터 가져와 내부 DB에 적재하는 역할을 담당합니다.
필요시 수동으로 실행되며, 대규모 데이터를 안정적으로 이전하는 데 초점을 맞춥니다.
+ `SyncService` - 증분 동기화<br>
서비스 운영 중, 변경된 데이터를 가져와 데이터의 최신성을 유지하는 역할을 합니다.

---

## 성능 최적화: `발상의 전환`으로 API 호출 99% 감소
하지만 여전히 문제가 남아있었습니다.
3만건 이상의 데이터를 가져오기 위해 API를 3만 번 호출하는 것은 비효율적이라고 누구나 생각할 것입니다.
여기서 "데이터를 `낱개가 아닌 묶음`으로 다루자"는 발상의 전환을 하게 되었고,
`페이지 단위 Bulk 처리` 전략을 도입했습니다.

+ Bulk API Read<br>
TourAPI의 `areaBasedList`는 `pageNo`와 `numOfRows` 파라미터를 통해 페이지네이션을 지원합니다.<br>
이를 활용해 API를 1회 호출할 때마다 100건의 데이터를 `페이지`단위로 한 번에 받아왔습니다.
+ Bulk DB Write<br>
조회한 100건의 데이터를 List<Place> 형태로 가공한 뒤, JPA의 `saveAll()`메서드를 사용하여<br>단 한 번의 트랜잭션으로 DB에 저장했습니다.<br>이는 건마다 `save()`를 호출할 때 발생하는 수많은 I/O를 획기적으로 줄이는게 가능했습니다.

이 전략의 도입으로, 대규모 데이터를 가져오기 위해 필요했던 호출 횟수는 99% 감소했으며,<br>초기 데이터 적재에 필요한 시간을 큰 폭으로 단축시킬 수 있었습니다.

---

## 안정성 확보
최적화는 기능적 효율성을 목표로 했다면, 이는 미완성인 프로젝트라고 생각합니다.
수백 번의 API 호출과 DB 저장이 일어나는 긴 작업 시간동안 장애는 언제든 발생할 수 있습니다.
### `중단/재개` 로직으로 배치 안정성 확보
`LoadService`가 300페이지 중 150번째 페이지를 처리하다 중단된다면?<br>다음 실행 시 어디서부터 다시 시작해야 할까요?<br>이 문제 해결을 위해 '체크포인트' 개념을 도입했습니다.
1. `상태 기록`<br>페이지 단위 작업이 성공할 때마다, 마지막으로 성공한 `areaCode`와 `pageNo`를 별도의 `SyncLog`테이블에 기록합니다.
2. `작업 재개`<br>`LoadService`가 다시 시작될 때, `SyncLog`테이블을 조회하여 마지막 성공 지점부터 작업을 이어갑니다.

이 재개 로직의 채택으로 전체 데이터 적재 과정이 중단되더라도 관리자의 개입을 최소화하며 장애 복구를 가능하게 하는 배치 시스템을 구축할 수 있었습니다.
